const express = require("express")
const User = require("../models/User")
const bcrypt = require("bcryptjs")
const jwt = require("jsonwebtoken")
const { body, validationResult } = require('express-validator');
const fetchuser = require("../middleware/fetchuser")
const router = express.Router()

// Uses a version 16.15.0 for express-validator.

// jsonwebtoken .sign() take 2 parameters data and secretorPrivteKey. Threfore, our secretorPrivateKey is -
const JWT_SECRET_KEY = "thisisititisthis23$"

// Route-1: Create a User using - POST "/api/auth/createuser". Login not required
router.post("/createuser", [
    body("name", "Atleast 3 characters long!").isLength({ min: 3 }),
    body("email", "Invalid Email!").isEmail(),
    body("password", "Password must be atleast 8 to 16 characters long!").isLength({ min: 8, max: 16 })
], async (req, res) => {
    // Finds the validation errors in this request and wraps them in an object with handy functions
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    try {

        // Encrypt password using bcryptjs node package so that user password will be secured and salt to it which is also generated by bcrypt for extra protection. We use await on it because it returns a promise.
        const salt = await bcrypt.genSalt(10)
        const securePassword = await bcrypt.hash(req.body.password, salt)

        // chech whether user with this email exists already
        let user = await User.findOne({ email: req.body.email })
        if (user) {
            return res.status(400).json({ error: "E-mail already exist! Please enter a new one." });
        }
        // creates a new user
        user = await User.create({
            name: req.body.name,
            email: req.body.email,
            password: securePassword
        })

        // Data retrieval will fastest with id because it id is our indexes in database by default therefore we will retrieve data in .sign() of jwt using id

        const data = {
            user: {
                id: user.id
            }
        }

        // after generating authentication token with below function of jwt, we can verify that token using jwt.verify()
        const authToken = jwt.sign(data, JWT_SECRET_KEY)

        res.json({ authToken })

    }
    catch (error) {
        console.error(error.message)
        return res.status(500).send("Internal Server Error!")
    }
});

// Route-2: Create a login using - POST "/api/auth/login". Login not required
router.post("/login", [
    body("email", "Invalid Email!").isEmail(),
    body("password", "Password field cannot be blank").exists()
], async (req, res) => {
    // Finds the validation errors in this request and wraps them in an object with handy functions
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    // Extract email and password from req.body using destructuring.
    const { email, password } = req.body

    try {

        let user = await User.findOne({ email })
        if (!user) {
            return res.status(400).json({ error: "Please try to login with correct credentials!!" })
        }

        const passwordCompare = await bcrypt.compare(password, user.password)
        if (!passwordCompare) {
            return res.status(400).json({ error: "Please try to login with correct credentials!!" })
        }

        const data = {
            user: {
                id: user.id
            }
        }

        const authToken = jwt.sign(data, JWT_SECRET_KEY)

        res.json({ authToken })

    } catch (error) {
        console.error(error.message)
        return res.status(500).send("Internal Server Error!")
    }
});

// Route-3: Create a getuser using - POST "/api/auth/getuser". Login required
router.post("/getuser", fetchuser, async (req, res) => {

    try {

        const userId = req.user.id
        let user = await User.findById(userId).select("-password")
        res.send(user)

    } catch (error) {
        console.error(error.message)
        return res.status(500).send("Internal Server Error!")
    }
});

module.exports = router;